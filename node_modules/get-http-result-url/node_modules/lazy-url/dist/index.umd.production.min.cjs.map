{"version":3,"file":"index.umd.production.min.cjs","sources":["../src/index.ts"],"sourcesContent":["/**\n * Created by user on 2019/6/6.\n */\n\nimport urlParse, { StringifyQuery, URLPart } from 'url-parse';\nimport SymbolInspect from 'symbol.inspect';\nimport { inspect } from 'util';\nimport { typePredicates } from 'ts-type-predicates';\nimport errcode from 'err-code';\nimport { _fixReplaceURLProtocol } from 'replace-url-protocol';\nimport { errorsToMessageList, messageWithSubErrors } from 'err-indent';\nimport { errStackMeta, stringifyStackMeta } from 'err-stack-meta';\n\nexport type IURLLike = string | URL | IURLObjectLike;\nexport const SYM_URL = Symbol('url');\nexport const SYM_HIDDEN = Symbol('hidden');\n\nexport const enum ENUM_FAKE\n{\n\tprotocol = 'fake+http:',\n\thostname = 'url-fake-hostname',\n}\n\nconst SymbolContext = findSymbolContext();\n\nexport class LazyURL extends URL implements URL\n{\n\t/**\n\t * @deprecated\n\t */\n\tprotected [SYM_URL]?: URL;\n\tprotected [SYM_HIDDEN]: Partial<URL>;\n\n\tstatic create(url: IURLLike | [IURLLike, IURLLike?], base?: IURLLike)\n\t{\n\t\treturn new this(url, base)\n\t}\n\n\tconstructor(url: IURLLike | [IURLLike, IURLLike?], base?: IURLLike)\n\t{\n\t\tlet u = _core(url, base)\n\n\t\tsuper(u.url.href);\n\n\t\t//this[SYM_URL] = _url;\n\t\tthis[SYM_HIDDEN] = u.hidden;\n\n\t\t//_numerable(this)\n\t}\n\n\t/*\n\t[SymbolInspect]()\n\t{\n\t\treturn `LazyURL {\n  href: '${this.href}',\n  href: '${this.toRealString()}',\n  origin: '${this.origin}',\n  protocol: '${this.protocol}',\n  username: '${this.username}',\n  password: '${this.password}',\n  host: '${this.host}',\n  hostname: '${this.hostname}',\n  port: '${this.port}',\n  pathname: '${this.pathname}',\n  search: '${this.search}',\n  searchParams: ${util.inspect(this.searchParams)},\n  hash: '${this.hash}'\n}`;\n\t}\n\t */\n\n\t/*\n\t[SymbolInspect]()\n\t{\n\t\treturn `LazyURL(${this.href})`;\n\t}\n\n\t */\n\n\tget paths(): string[]\n\t{\n\t\tif (SymbolContext != null && this[SymbolContext] && Array.isArray(this[SymbolContext].path))\n\t\t{\n\t\t\treturn this[SymbolContext].path.slice();\n\t\t}\n\n\t\treturn this.pathname\n\t\t\t.split('/')\n\t\t\t.filter(v => v !== '')\n\t}\n\n\tfakeExists()\n\t{\n\t\treturn this.fakeKeys().length\n\t}\n\n\tfakeKeys()\n\t{\n\t\treturn Object.keys(this[SYM_HIDDEN])\n\t}\n\n\tfakeEntries()\n\t{\n\t\treturn Object.entries(this[SYM_HIDDEN])\n\t}\n\n\t/**\n\t * get the real url (remove fake value)\n\t * throw error if not a valid url\n\t *\n\t * @returns {string}\n\t */\n\ttoRealString(options?: {\n\t\tignoreInvalid?: boolean,\n\t\tstringify?: StringifyQuery,\n\t})\n\t{\n\t\tlet ks = this.fakeEntries();\n\n\t\tif (ks.length)\n\t\t{\n\t\t\tlet u = urlParse(this.href);\n\n\t\t\tks\n\t\t\t\t.forEach(([name, value]) =>\n\t\t\t\t{\n\t\t\t\t\tif (u[name] === value)\n\t\t\t\t\t{\n\t\t\t\t\t\tu.set(name as any, '');\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t;\n\n\t\t\tif (u.host === '')\n\t\t\t{\n\t\t\t\tif (options?.ignoreInvalid)\n\t\t\t\t{\n\t\t\t\t\tu.set('username', '');\n\t\t\t\t\tu.set('password', '');\n\t\t\t\t\tu.set('port', '');\n\t\t\t\t\tu.set('protocol', '');\n\t\t\t\t}\n\t\t\t\telse if (u.username !== '' || u.password !== '' || u.port !== '' || u.protocol !== '')\n\t\t\t\t{\n\t\t\t\t\t//throw new TypeError(`Invalid URL ${u}`)\n\n\t\t\t\t\tthrow _wrapError(new TypeError(`Invalid URL`), u)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet s = u.toString(options?.stringify);\n\n\t\t\tif (u.protocol === '' && u.host === '')\n\t\t\t{\n\t\t\t\ts = s.replace(/^\\/\\//, '');\n\t\t\t}\n\n\t\t\treturn s\n\t\t}\n\n\t\treturn this.href;\n\t}\n\n\toverride toString()\n\t{\n\t\treturn this.href;\n\t}\n\n\t/*\n\ttoJSON()\n\t{\n\t\treturn this[SYM_URL].toJSON();\n\t}\n\t */\n\n\t/*\n\tget hash()\n\t{\n\t\treturn this[SYM_URL].hash\n\t}\n\n\tset hash(value)\n\t{\n\t\tthis[SYM_URL].hash = value\n\t}\n\n\tget host()\n\t{\n\t\treturn this[SYM_URL].host\n\t}\n\n\tset host(value)\n\t{\n\t\tdelete this[SYM_HIDDEN].hostname;\n\n\t\tthis[SYM_URL].host = value\n\t}\n\t */\n\n\toverride get hostname()\n\t{\n\t\treturn super.hostname\n\t}\n\n\toverride set hostname(value)\n\t{\n\t\tif (!isFakeHostname(value))\n\t\t{\n\t\t\tdelete this[SYM_HIDDEN].hostname;\n\t\t}\n\n\t\tsuper.hostname = value\n\t}\n\n\toverride get href()\n\t{\n\t\treturn super.href\n\t}\n\n\toverride set href(value: string)\n\t{\n\t\tsuper.href = value\n\n\t\tif (isFakeProtocol(super.protocol))\n\t\t{\n\t\t\tthis[SYM_HIDDEN].protocol = ENUM_FAKE.protocol\n\t\t}\n\n\t\tif (isFakeHostname(super.hostname))\n\t\t{\n\t\t\tthis[SYM_HIDDEN].hostname = ENUM_FAKE.hostname\n\t\t}\n\t}\n\n\toverride get origin(): string\n\t{\n\t\tlet origin = super.origin;\n\n\t\tif ((typeof origin === 'undefined' || origin === null || origin === 'null' || origin === 'undefined') && super.protocol.length)\n\t\t{\n\t\t\t/**\n\t\t\t * @see https://github.com/nodejs/node/issues/39732#issuecomment-896624653\n\t\t\t */\n\t\t\torigin = super.protocol + '//' + super.hostname;\n\t\t}\n\n\t\treturn origin\n\t}\n\n\t/*\n\n\tget password()\n\t{\n\t\treturn this[SYM_URL].password\n\t}\n\n\tset password(value)\n\t{\n\t\tthis[SYM_URL].password = value\n\t}\n\n\tget pathname()\n\t{\n\t\treturn this[SYM_URL].pathname\n\t}\n\n\tset pathname(value)\n\t{\n\t\tthis[SYM_URL].pathname = value\n\t}\n\n\t */\n\n\toverride get port(): string\n\t{\n\t\treturn super.port\n\t}\n\n\toverride set port(value: string | number)\n\t{\n\t\tif (typeof value === 'string' && value !== '')\n\t\t{\n\t\t\tlet old = value.toString().trim();\n\n\t\t\tvalue = parseInt(value)\n\n\t\t\tif (old !== value.toString())\n\t\t\t{\n\t\t\t\tthrow new TypeError(`Invalid port input: { '${old}' => ${value} }`)\n\t\t\t}\n\t\t}\n\n\t\tif (typeof value === 'number')\n\t\t{\n\t\t\tif (Number.isNaN(value) || !Number.isFinite(value) || value < 0 || value > 65535)\n\t\t\t{\n\t\t\t\tthrow new RangeError(`Invalid port range: ${value}`)\n\t\t\t}\n\n\t\t\tvalue = value.toString();\n\t\t}\n\n\t\tsuper.port = value ?? ''\n\t}\n\n\toverride get protocol()\n\t{\n\t\treturn super.protocol\n\t}\n\n\toverride set protocol(value)\n\t{\n\t\tif (typeof value !== 'string' || value.length < 2 || !value.endsWith(':'))\n\t\t{\n\t\t\tthrow new TypeError(`Invalid protocol input: ${value}`)\n\t\t}\n\n\t\tif (!isFakeProtocol(value))\n\t\t{\n\t\t\tdelete this[SYM_HIDDEN].protocol;\n\t\t}\n\n\t\tconst old = super.protocol;\n\n\t\tif (old !== value)\n\t\t{\n\t\t\tsuper.protocol = value;\n\n\t\t\t/**\n\t\t\t * avoid bug of https://github.com/nodejs/node/issues/39732\n\t\t\t */\n\t\t\t_fixReplaceURLProtocol(this, old, value);\n\t\t}\n\t}\n\n\tget auth(): string\n\t{\n\t\tif (this.username?.length)\n\t\t{\n\t\t\treturn `${this.username}:${this.password ?? ''}`\n\t\t}\n\n\t\treturn ''\n\t}\n\n\tset auth(value: string)\n\t{\n\t\tthis.username = '';\n\t\tthis.password = '';\n\n\t\tlet ls = value?.split(':')\n\n\t\tif (ls?.length)\n\t\t{\n\t\t\tthis.username = ls.shift();\n\t\t\tthis.password = ls.join(':');\n\t\t}\n\t}\n\n\t/*\n\tget search()\n\t{\n\t\treturn this[SYM_URL].search\n\t}\n\n\tset search(value)\n\t{\n\t\tthis[SYM_URL].search = value\n\t}\n\n\tget searchParams()\n\t{\n\t\treturn this[SYM_URL].searchParams\n\t}\n\n\tget username()\n\t{\n\t\treturn this[SYM_URL].username\n\t}\n\n\tset username(value)\n\t{\n\t\tthis[SYM_URL].username = value\n\t}\n\n\t */\n\n\t/**\n\t * @alias protocol\n\t */\n\tget scheme()\n\t{\n\t\treturn this.protocol\n\t}\n\n\t/**\n\t * @alias protocol\n\t */\n\tset scheme(value: string)\n\t{\n\t\tthis.protocol = value;\n\t}\n\n\t/**\n\t * @alias hash\n\t */\n\tget fragment()\n\t{\n\t\treturn this.hash\n\t}\n\n\t/**\n\t * @alias hash\n\t */\n\tset fragment(value: string)\n\t{\n\t\tthis.hash = value;\n\t}\n\n\t/**\n\t * @alias search\n\t */\n\tget query()\n\t{\n\t\treturn this.search\n\t}\n\n\t/**\n\t * @alias search\n\t */\n\tset query(value: string)\n\t{\n\t\tthis.search = value;\n\t}\n\n\ttoObject(): IURLObject\n\t{\n\t\treturn LazyURL.toObject(this)\n\t}\n\n\t/**\n\t * clone into a object\n\t *\n\t * @returns {IURLObject}\n\t */\n\tstatic toObject(url: URL): IURLObject\n\t{\n\t\treturn LazyURL.keys().reduce((a, b) =>\n\t\t{\n\t\t\tif (b === 'searchParams')\n\t\t\t{\n\t\t\t\ta[b] = new URLSearchParams(url.searchParams.entries() as any as [string, string][])\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta[b] = url[b];\n\t\t\t}\n\n\t\t\treturn a\n\t\t}, {} as IURLObject)\n\t}\n\n\tkeys(): IUrlKeys[]\n\t{\n\t\treturn LazyURL.keys()\n\t}\n\n\tvalues()\n\t{\n\t\treturn LazyURL.values(this)\n\t}\n\n\tentries(): IEntries\n\t{\n\t\treturn LazyURL.entries(this)\n\t}\n\n\tstatic keys(): IUrlKeys[]\n\t{\n\t\treturn [\n\t\t\t'href',\n\t\t\t'protocol',\n\t\t\t'username',\n\t\t\t'password',\n\t\t\t'host',\n\t\t\t'hostname',\n\t\t\t'port',\n\t\t\t'pathname',\n\t\t\t'search',\n\t\t\t'searchParams',\n\t\t\t'hash',\n\t\t]\n\t}\n\n\tstatic values(url: URL)\n\t{\n\t\treturn LazyURL.keys().map(name => url[name])\n\t}\n\n\tstatic entries(url: URL): IEntries\n\t{\n\t\treturn LazyURL.keys().map(name => [name, url[name]]) as IEntries\n\t}\n\n\tcreateURLSearchParams(init?: string[][] | Record<string, string> | string | URLSearchParams | URL)\n\t{\n\t\tif (init instanceof URL)\n\t\t{\n\t\t\tinit = init.searchParams;\n\t\t}\n\n\t\treturn new URLSearchParams(init)\n\t}\n\n\tset<K extends Extract<URLPart, keyof LazyURL>>(part: K, value: LazyURL[K])\n\t{\n\t\tthis[part] = value\n\t}\n\n\tget<K extends Extract<URLPart, keyof LazyURL>>(part: K): LazyURL[K]\n\t{\n\t\treturn this[part]\n\t}\n\n}\n\nexport type IEntries = ([\"hash\" | \"host\" | \"hostname\" | \"href\" | \"password\" | \"pathname\" | \"port\" | \"protocol\" | \"search\" | \"username\", string] | [\"searchParams\", URLSearchParams])[]\n\nexport type IEntriesRow<T extends IUrlKeys> = [T, URL[T]]\n\nfunction _numerable(lib)\n{\n\tlet ds = Object.getOwnPropertyDescriptors(lib);\n\n\t([\n\t\t'href',\n\t\t'protocol',\n\t\t'username',\n\t\t'password',\n\t\t'host',\n\t\t'hostname',\n\t\t'port',\n\t\t'pathname',\n\t\t'search',\n\t\t'searchParams',\n\t\t'hash',\n\t] as const)\n\t\t.forEach((name) =>\n\t\t{\n\t\t\tif (name in ds)\n\t\t\t{\n\t\t\t\tds[name].enumerable = true;\n\n\t\t\t\tObject.defineProperty(lib, name, ds[name])\n\t\t\t}\n\t\t})\n\t;\n}\n\nexport type IUrlKeys =\n\t| 'href'\n\t| 'username'\n\t| 'password'\n\t| 'host'\n\t| 'hostname'\n\t| 'port'\n\t| 'pathname'\n\t| 'search'\n\t| 'searchParams'\n\t| 'protocol'\n\t| 'hash'\n\t;\n\nexport function findSymbolContext(): symbol\n{\n\tlet u = _newURL(`https://localhost`);\n\n\tconst SymbolContext = Object.getOwnPropertySymbols(u)\n\t\t.filter(sym => u[sym].host == 'localhost')[0]\n\t;\n\n\treturn SymbolContext;\n}\n\nexport interface IURLObjectLike\n{\n\thref: string;\n}\n\nexport interface IURLObject\n{\n\thref: string;\n\tprotocol: string;\n\tusername: string;\n\tpassword: string;\n\thost: string;\n\thostname: string;\n\tport: string;\n\tpathname: string;\n\tsearch: string;\n\tsearchParams: URLSearchParams;\n\thash: string;\n}\n\n/**\n * @private\n */\nexport function _core(url: IURLLike | [IURLLike, IURLLike?], base?: IURLLike)\n{\n\tif (Array.isArray(url))\n\t{\n\t\tif (base == null)\n\t\t{\n\t\t\t[url, base] = url;\n\t\t}\n\t}\n\n\tif (typeof url !== 'undefined' && url !== null)\n\t{\n\t\tif (url instanceof LazyURL)\n\t\t{\n\t\t\turl = url.toRealString();\n\t\t}\n\t\telse if (url instanceof URL)\n\t\t{\n\t\t\turl = url.href;\n\t\t}\n\t\telse if (typeof (url as IURLObjectLike).href === 'string')\n\t\t{\n\t\t\turl = (url as IURLObjectLike).href;\n\t\t\tbase ??= (url as any as HTMLLinkElement).baseURI;\n\t\t}\n\t}\n\n\tif (typeof url !== 'string')\n\t{\n\t\tthrow _wrapError(new TypeError(`Argument '${inspect(url)}' is not assignable to url like.`), url, base)\n\t}\n\n\tlet _url: URL;\n\tconst _hidden_: Partial<URL> = {};\n\n\tif (typeof base !== 'string' && base != null && typeof base.href === 'string')\n\t{\n\t\tbase = base.href;\n\t}\n\n\tif (base === '')\n\t{\n\t\tbase = void 0;\n\t}\n\n\ttry\n\t{\n\t\t_url = _newURL(url, base as string)\n\t}\n\tcatch (e: unknown)\n\t{\n\t\tlet ok: boolean;\n\n\t\ttypePredicates<IURLError>(e);\n\n\t\tif (e.code === 'ERR_INVALID_URL' || /Invalid URL/.test(e.message))\n\t\t{\n\t\t\tif (typeof base === 'string')\n\t\t\t{\n\t\t\t\tlet old = base;\n\t\t\t\tlet u = urlParse(base)/* as URL & {\n\t\t\t\t\t\tset(name: keyof URL, value: string): void\n\t\t\t\t\t}*/;\n\n\t\t\t\tif ((\n\t\t\t\t\tu.host === ''\n\t\t\t\t\t|| u.protocol === ''\n\t\t\t\t))\n\t\t\t\t{\n\t\t\t\t\tif (!old.includes('/') && [\n\t\t\t\t\t\tu.protocol + u.host,\n\t\t\t\t\t\tu.protocol + u.pathname,\n\t\t\t\t\t].includes(old.toLowerCase()))\n\t\t\t\t\t{\n\t\t\t\t\t\tu = urlParse('');\n\n\t\t\t\t\t\tu.set('host', old);\n\t\t\t\t\t\tu.set('protocol', ENUM_FAKE.protocol);\n\t\t\t\t\t\tu.set('pathname', '');\n\n\t\t\t\t\t\t_hidden_.protocol = ENUM_FAKE.protocol;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (u.host === '')\n\t\t\t\t\t{\n\t\t\t\t\t\tif (u.pathname != '' && !u.pathname.includes('/'))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tu.set('host', u.pathname);\n\t\t\t\t\t\t\tu.set('pathname', '');\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tu.set('host', ENUM_FAKE.hostname);\n\n\t\t\t\t\t\t\t_hidden_.hostname = u.hostname;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (u.protocol === '')\n\t\t\t\t\t{\n\t\t\t\t\t\tu.set('protocol', ENUM_FAKE.protocol);\n\t\t\t\t\t\t_hidden_.protocol = u.protocol;\n\t\t\t\t\t}\n\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tif (u.pathname !== '' && !u.pathname.startsWith('/'))\n\t\t\t\t\t{\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tu.set('pathname', '/' + u.pathname);\n\t\t\t\t\t}\n\n\t\t\t\t\t_url = _newURL(url, u.toString());\n\n\t\t\t\t\tok = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ((url == null || url === '') && base == null)\n\t\t\t{\n\n\t\t\t}\n\t\t\telse if (url != null && base == null)\n\t\t\t{\n\t\t\t\tbase = `${ENUM_FAKE.protocol}//${ENUM_FAKE.hostname}`;\n\n\t\t\t\t_url = _newURL(url, base);\n\n\t\t\t\t_hidden_.protocol = ENUM_FAKE.protocol;\n\t\t\t\t_hidden_.hostname = ENUM_FAKE.hostname;\n\n\t\t\t\tok = true;\n\t\t\t}\n\t\t}\n\n\t\tif (!ok)\n\t\t{\n\t\t\tthrow e\n\t\t}\n\t}\n\n\treturn {\n\t\turl: _url,\n\t\thidden: _hidden_,\n\t}\n}\n\nexport interface IURLErrorNode extends Error\n{\n\tcode: 'ERR_INVALID_URL' | string,\n\tinput: IURLLike,\n}\n\nexport interface IURLError extends IURLErrorNode\n{\n\tbaseURL: IURLLike,\n}\n\nfunction _wrapError<T extends Error>(e: T, input: IURLLike | [IURLLike, IURLLike?], baseURL?: IURLLike, errInvalidUrl?: boolean): T & IURLError\n{\n\ttypePredicates<IURLError>(e);\n\n\tlet message = e.message;\n\n\tif (message === 'Invalid URL' || e.code === 'ERR_INVALID_URL' || errInvalidUrl)\n\t{\n\t\tmessage = messageWithSubErrors(e, [\n\t\t\te,\n\t\t\t{\n\t\t\t\tinput,\n\t\t\t\tbaseURL,\n\t\t\t},\n\t\t])\n\n\t\tlet meta = errStackMeta(e);\n\n\t\te.stack = errorsToMessageList([\n\t\t\te,\n\t\t\t{\n\t\t\t\tinput,\n\t\t\t\tbaseURL,\n\t\t\t},\n\t\t], {}, e).concat([meta.stack]).join('\\n');\n\n\t}\n\n\tif (e.message !== message)\n\t{\n\t\te.message = message;\n\t}\n\n\tlet err = errcode(e, e.code ?? 'ERR_INVALID_URL', {\n\t\tinput,\n\t\tbaseURL,\n\t});\n\n\treturn err as any\n}\n\nfunction _newURL(input: string | URL, baseURL?: string | URL)\n{\n\ttry\n\t{\n\t\treturn new URL(input, baseURL)\n\t}\n\tcatch (e: unknown)\n\t{\n\t\tthrow _wrapError(e as IURLError, input, baseURL);\n\t}\n}\n\nexport function isFakeProtocol(protocol: string): protocol is ENUM_FAKE.protocol\n{\n\treturn protocol === ENUM_FAKE.protocol\n}\n\nexport function isFakeHostname(hostname: string): hostname is ENUM_FAKE.protocol\n{\n\treturn hostname === ENUM_FAKE.hostname\n}\n\nexport default LazyURL\n"],"names":["SYM_URL","Symbol","SYM_HIDDEN","ENUM_FAKE","exports","SymbolContext","LazyURL","URL","static","url","base","constructor","u","href","paths","this","Array","path","slice","pathname","split","username","password","port","protocol","_wrapError","TypeError","s","options","replace","hostname","super","value","isFakeHostname","origin","_value","old","parseInt","ls","length","scheme","hash","fragment","search","toObject","keys","reduce","a","b","map","name","createURLSearchParams","init","URLSearchParams","set","part","get","_newURL","filter","sym","host"],"mappings":"+vBASA,MAAAA,EAAAC,OAAA,OAEAC,EAAAD,OAAA,UAIA,IAAAE,EADAC,EAAAD,eAAA,GACAA,EAICA,cAJDA,EAAAA,UAAA,KAEAA,SAAAA,aAAAA,EAAAA,SAAAA,oBAMmB,MAAAE,sBAEN,MAAAC,gBAAmBC,IAU9BC,cAAAC,EAAAC,wBAOAC,YAAAF,EAAWC,GAMX,IAAAE,EAAAH,MAAAA,EAAAC,SAkDOD,EAAAA,IAA6BI,WAG1BX,GAAAU,SAgBVE,4BAGAC,SAAAC,4BAGGC,KAAAA,GAAAA,KAAAC,QAlCHH,KAAAI,SAIAC,MAAA,uZAiHA,GAAA,KAAAR,EAAAS,UAAA,KAAAT,EAAAU,UAAA,KAAAV,EAAAW,MAAA,KAAAX,EAAAY,SAGC,MAAAC,WAAA,IAAAC,UAAA,eAAAd,OAQDe,EAAAf,EAAAgB,SAAAA,MAAAA,OAAA,EAAAA,aASC,MAP6B,KAA/BhB,EAAaY,UAAkBZ,KAAAA,EAAAA,OAE9Be,EAAAA,EAAKE,QAAC,QAAO,KAKZF,EAKA,OAAAZ,KAAAF,iCA0CFiB,iHAwBGjB,WAGD,OAAAkB,MAAAlB,iBAQDmB,MAAAA,KAAAA,uBAIgBR,oBAGfA,SAAA,cAIAS,eACAF,MAAAD,iBAID5B,GAAY4B,SAEX,wCAWDC,MAAAG,uBAEgBA,SAAAA,GAAAA,cAAAA,IAAAA,MAAAA,SAAAA,SACfA,EAAAH,MAAAP,SAAA,KAAAO,MAAAD,yCAiBDP,SAAAS,GAAA,IAAAG,KAmCO,oBAAa,KAAAH,EAAA,CACrBI,IAAAA,EAAAA,EAAAA,WAAAA,eAOCJ,EAAAK,SAAAL,eAQO,MAAA,IAAIN,UAAA,0BAAAU,SAAAJ,OAcZ,GAAS,iBAAAA,EAAA,gKAyBRR,obAoCWT,KAAAM,SAAA,iBAEA,qCAGFiB,MAAAA,GAAAA,EAAAC,uBAEFD,wBAEPA,0BAUA,OAAAvB,KAAAS,SAMCgB,WAAAR,GAGDjB,KAAWS,SAAAQ,wBAUXjB,KAAA0B,KASOC,aAAAV,QAIPS,KAAAT,cAIU,OAAAjB,KAAA4B,iBAIAX,iBAIAY,kBACTtC,QAAAsC,SAAS7B,MAMRP,gBAAAC,GACA,OAAAH,QAAAuC,OAAAC,QAAA,CAAAC,EAAAC,UAGH,iBAAAA,yDAHG,2HA4ED,MAAA,CAAA,OAAA,WAAA,WAED,WAIA,OACA,WAGa,OAIb,oBAMA,eAIA,yBAUC,OAAA1C,eAAW2C,KAAAC,UASN1C,eAAAC,GAGHH,OAAAA,QAAAA,OAAAA,KAAAA,GAAAA,CAAAA,EAAAA,EAAAA,MAGC6C,sBAAAC,GAWD,OAPCA,aAAA7C,MACA6C,EAAAA,EAAAA,cAMD,IAAAC,gBAAAD,GAKEE,IAAAC,EAAAvB,GAGDjB,KAAAwC,GAAAvB,EAICwB,IAAAD,GAGF,OAAAxC,KAAAwC,iCAuED,IAAA3C,EAAA6C,QAAA,4DAKFC,QAAAC,GAJC,aAAA/C,EAAA+C,GAAAC,OAID,oXAqCD,iBAAAlD,GAAA,MAAAA,GAAA,iBAAAA,EAAAG,OAGKH,EAAAA,EAAAA,MAGLA,KAAAA,IAEDA,OAAA"}