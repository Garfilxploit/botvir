{"version":3,"file":"index.cjs.production.min.cjs","sources":["../src/util/trim.ts","../src/util/isUnset.ts","../src/util/isNumOnly.ts","../src/index.ts"],"sourcesContent":["export function trim(s: string)\n{\n\treturn s.trim();\n}\n","\nexport function isUnset(v: any): v is undefined | null\n{\n\treturn typeof v === 'undefined' || v === null\n}\n","\nexport function isNumOnly(v: any)\n{\n\tif (typeof v === 'number' || typeof v === 'string')\n\t{\n\t\treturn /^\\d+$/.test(v.toString())\n\t}\n\n\treturn false\n}\n","import { ITSPickExtra, ITSRequireAtLeastOne } from 'ts-type/lib/type/record';\nimport { lineSplit, R_CRLF, LF } from 'crlf-normalize';\nimport { IEvalTrace, IParsed, IParsedWithoutTrace, ISource, ITrace, IRawLineTrace, ITraceValue } from './types';\nimport { stringSplitWithLimit } from 'string-split-keep2';\nimport { trim } from './util/trim';\nimport { isUnset } from './util/isUnset';\nimport { isNumOnly } from './util/isNumOnly';\nimport errcode from 'err-code';\nimport { inspect } from 'util';\n\nconst AT = 'at' as const\n\n// 1.\n// Error: foo\n// 2.\n// TypeError: foo\nconst REGEX_MATCH_MESSAGE = /^([a-z][a-z0-9_]*)(?:(?: \\[(\\w+)\\])?:(?: ([\\s\\S]*))?)?$/i\n\nconst REGEX_MATCH_MESSAGE_LOOSE = new RegExp(REGEX_MATCH_MESSAGE.source, REGEX_MATCH_MESSAGE.flags + 'm');\n\nconst REGEX_REMOVE_AT = /^at\\s+/\nconst REGEX_STARTS_WITH_EVAL_AT = /^eval\\s+at\\s+/\n\nconst REGEX_MATCH_INDENT = /^([ \\t]*)(.+)$/;\n\nexport function breakBrackets(str: string, first: string, last: string)\n{\n\tif (!str.endsWith(last))\n\t{\n\t\treturn [str]\n\t}\n\n\tlet firstIndex\n\tlet cursor = str.length - 1\n\t// There is already the last one\n\tlet count = 1\n\twhile (--cursor >= 0)\n\t{\n\t\tconst char = str.charAt(cursor)\n\t\tif (char === last)\n\t\t{\n\t\t\tcount++\n\t\t}\n\t\telse if (char === first)\n\t\t{\n\t\t\tif (--count === 0)\n\t\t\t{\n\t\t\t\tfirstIndex = cursor\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\treturn [\n\t\tstr.slice(0, firstIndex),\n\t\tstr.slice(firstIndex + 1, -1),\n\t].map(trim)\n}\n\nexport function validPosition(source: {\n\tline?: string | number,\n\tcol?: string | number,\n})\n{\n\tif (!isUnset(source))\n\t{\n\t\tif (typeof source === 'object' && isUnset(source.line) && isUnset(source.col))\n\t\t{\n\t\t\treturn null\n\t\t}\n\n\t\treturn isNumOnly(source.line) && isNumOnly(source.col)\n\t}\n\n\treturn false\n}\n\nexport function parseSource(rawSource: string): ISource\n{\n\tconst [source, line, col] = stringSplitWithLimit(rawSource, ':', -3);\n\n\tif (!col?.length || !line?.length)\n\t{\n\t\treturn {\n\t\t\tsource: rawSource,\n\t\t}\n\t}\n\n\treturn {\n\t\tsource,\n\t\tline,\n\t\tcol,\n\t}\n}\n\nexport function parseEvalSource(rawEvalSource: string): Omit<IEvalTrace, 'callee' | 'calleeNote' | 'eval'>\n{\n\tconst { indent, rawLine } = _detectIndent(rawEvalSource);\n\n\tconst [rawTrace, rawEvalTrace] = rawLine\n\t\t.replace(REGEX_STARTS_WITH_EVAL_AT, '')\n\t\t.split(/,\\s+/g)\n\t\t.map(trim)\n\n\tconst {\n\t\teval: ev,\n\t\tcallee: evalCallee,\n\t\tcalleeNote: evalCalleeNote,\n\t\t...trace\n\t} = parseTrace(rawTrace)\n\n\tconst evalTrace = parseSource(rawEvalTrace)\n\n\treturn {\n\t\tevalCallee,\n\t\tevalCalleeNote,\n\t\t...trace,\n\t\tevalTrace,\n\t\tindent,\n\t}\n}\n\nexport function _detectIndent(trace: string)\n{\n\tconst [, indent, rawLine] = REGEX_MATCH_INDENT.exec(trace)\n\n\treturn {\n\t\tindent,\n\t\trawLine,\n\t}\n}\n\nexport function parseTrace(trace: string, testEvalSource: true): ITrace | IRawLineTrace\nexport function parseTrace(trace: string, testEvalSource?: false): ITrace\nexport function parseTrace(trace: string, testEvalSource?: boolean): ITrace | IRawLineTrace\nexport function parseTrace(trace: string, testEvalSource?: boolean)\n{\n\tconst { indent, rawLine } = _detectIndent(trace);\n\n\tconst t = rawLine.replace(REGEX_REMOVE_AT, '')\n\n\tlet [\n\t\trawCallee, rawSource,\n\t] = breakBrackets(t, '(', ')')\n\n\tif (!rawSource)\n\t{\n\t\t[rawCallee, rawSource] = [rawSource, rawCallee]\n\t}\n\n\tconst ret: ITrace = {} as any\n\n\tif (rawCallee)\n\t{\n\t\tconst [\n\t\t\tcallee, calleeNote,\n\t\t] = breakBrackets(rawCallee, '[', ']')\n\n\t\tret.callee = callee\n\t\tret.calleeNote = calleeNote\n\t}\n\telse\n\t{\n\t\tret.callee = rawCallee\n\t}\n\n\tif (ret.callee === 'eval')\n\t{\n\t\tret.eval = true\n\t}\n\n\tif (testEvalSource === true)\n\t{\n\t\tif (!rawLine.startsWith(AT))\n\t\t{\n\t\t\treturn <IRawLineTrace>{\n\t\t\t\traw: true,\n\t\t\t\tindent,\n\t\t\t\trawLine,\n\t\t\t}\n\t\t}\n\t}\n\n\tObject.assign(\n\t\tret,\n\t\ttestEvalSource && isEvalSource(rawSource)\n\t\t\t? parseEvalSource(rawSource)\n\t\t\t: parseSource(rawSource),\n\t)\n\n\tif (testEvalSource === true)\n\t{\n\t\tif (!validTrace(ret))\n\t\t{\n\t\t\treturn <IRawLineTrace>{\n\t\t\t\traw: true,\n\t\t\t\tindent,\n\t\t\t\trawLine,\n\t\t\t}\n\t\t}\n\t}\n\n\tret.indent = indent\n\n\treturn ret\n}\n\nexport function isEvalSource(rawSource: string)\n{\n\treturn REGEX_STARTS_WITH_EVAL_AT.test(rawSource)\n}\n\nexport function validTrace(trace: ITraceValue)\n{\n\tif (isRawLineTrace(trace))\n\t{\n\t\treturn false;\n\t}\n\n\treturn trace.eval || isNumOnly(trace.line) || isUnset(trace.callee) && trace.source?.length > 0 && validPosition(trace);\n}\n\nexport function parseBody(rawStack: string, detectMessage?: string)\n{\n\tlet rawTrace: string[];\n\tlet rawMessage: string\n\n\tif (!isUnset(detectMessage))\n\t{\n\t\tlet { type, message } = parseMessage(rawStack, true);\n\n\t\tlet mf = formatMessage({\n\t\t\ttype,\n\t\t\tmessage: detectMessage === '' ? message : detectMessage,\n\t\t});\n\n\t\tlet i = rawStack.indexOf(mf)\n\n\t\tif (i === 0)\n\t\t{\n\t\t\tlet s = rawStack.replace(mf, '')\n\t\t\tlet m = R_CRLF.exec(s)\n\n\t\t\tif (m?.index === 0)\n\t\t\t{\n\t\t\t\trawTrace = lineSplit(m.input.replace(m[0], ''));\n\n\t\t\t\trawMessage = mf\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!rawMessage?.length)\n\t{\n\t\t([rawMessage, ...rawTrace] = lineSplit(rawStack));\n\n\t\t// A error message might have multiple lines\n\t\tconst index = rawTrace.findIndex(line => line.trimLeft()\n\t\t\t.startsWith(AT) && validTrace(parseTrace(trim(line), true)));\n\n\t\trawMessage = [rawMessage, ...rawTrace.splice(0, index)].join(LF)\n\t}\n\n\treturn {\n\t\trawMessage,\n\t\trawTrace,\n\t}\n}\n\nexport function parseMessage(body: string, looseMode?: boolean): IParsedWithoutTrace\n{\n\ttry\n\t{\n\t\tconst [, type, code, message] = body.match(looseMode ? REGEX_MATCH_MESSAGE_LOOSE : REGEX_MATCH_MESSAGE);\n\n\t\treturn {\n\t\t\ttype,\n\t\t\tcode,\n\t\t\tmessage,\n\t\t}\n\t}\n\tcatch (e: any)\n\t{\n\t\te.message = `Failed to parse error message.\\nreason: ${e.message}\\nbody=${inspect(body)}`;\n\n\t\terrcode(e, {\n\t\t\tbody,\n\t\t});\n\n\t\tthrow e\n\t}\n}\n\nexport function parseStack(rawStack: string, detectMessage?: string): IParsed\n{\n\tif (typeof rawStack !== 'string')\n\t{\n\t\tthrow errcode(new TypeError('stack must be a string'), {\n\t\t\trawStack,\n\t\t\tdetectMessage,\n\t\t});\n\t}\n\n\ttry\n\t{\n\t\tconst { rawMessage, rawTrace } = parseBody(rawStack, detectMessage);\n\n\t\tconst {\n\t\t\ttype, code, message,\n\t\t} = parseMessage(rawMessage)\n\n\t\tconst traces = rawTrace.map(t => parseTrace(t, true))\n\n\t\treturn {\n\t\t\ttype,\n\t\t\tcode,\n\t\t\tmessage,\n\t\t\ttraces,\n\t\t\trawMessage,\n\t\t\trawTrace,\n\t\t\trawStack,\n\t\t}\n\t}\n\tcatch (e: any)\n\t{\n\t\terrcode(e, {\n\t\t\trawStack,\n\t\t\tdetectMessage,\n\t\t});\n\n\t\tthrow e;\n\t}\n}\n\nexport function formatTrace({\n\tcallee,\n\tcalleeNote,\n\tsource,\n\tline,\n\tcol,\n}: ITSPickExtra<ITrace, 'source'>)\n{\n\tconst sourceTrace = [\n\t\tsource,\n\t\tline,\n\t\tcol,\n\t]\n\t\t.filter(v => typeof v !== 'undefined')\n\t\t.join(':')\n\n\tconst note = calleeNote\n\t\t? ` [${calleeNote}]`\n\t\t: ''\n\n\treturn callee\n\t\t? `${callee}${note} (${sourceTrace})`\n\t\t: sourceTrace\n}\n\nexport function formatEvalTrace({\n\tcallee,\n\tevalTrace,\n\n\tevalCallee,\n\tevalCalleeNote,\n\n\t...trace\n}: IEvalTrace)\n{\n\treturn `${callee} (eval at ${formatTrace({\n\t\t...trace,\n\n\t\tcallee: evalCallee ?? '<anonymous>',\n\t\tcalleeNote: evalCalleeNote,\n\t})}, ${formatTrace(evalTrace)})`;\n}\n\nexport function formatMessagePrefix({\n\ttype,\n\tcode,\n}: IParsedWithoutTrace)\n{\n\tif (code?.length)\n\t{\n\t\ttype += ` [${code}]`;\n\t}\n\n\treturn `${type}`;\n}\n\nexport function formatMessage(parsed: IParsedWithoutTrace)\n{\n\tlet line = formatMessagePrefix(parsed);\n\n\tif (typeof parsed.message !== 'undefined')\n\t{\n\t\tline += `: ${parsed.message ?? ''}`;\n\t}\n\n\treturn line;\n}\n\nexport function formatRawLineTrace(trace: IRawLineTrace)\n{\n\treturn `${trace.indent ?? '    '}${trace.rawLine}`\n}\n\nexport function isRawLineTrace(trace: ITraceValue): trace is IRawLineTrace\n{\n\treturn (trace.raw === true)\n}\n\nexport function isEvalTrace(trace: ITraceValue): trace is IEvalTrace\n{\n\treturn (trace as IEvalTrace).eval === true\n}\n\nexport function formatTraceLine(trace: ITraceValue)\n{\n\tif (isRawLineTrace(trace))\n\t{\n\t\treturn formatRawLineTrace(trace)\n\t}\n\n\treturn `${trace.indent ?? '    '}at ${\n\t\tisEvalTrace(trace)\n\t\t\t? formatEvalTrace(trace)\n\t\t\t: formatTrace(trace)\n\t}`\n}\n\nexport class ErrorStack implements IParsed\n{\n\n\t/**\n\t * Error type\n\t */\n\ttype: string;\n\n\tcode?: string;\n\t/**\n\t * The message used by Error constructor\n\t */\n\tmessage: string;\n\ttraces: IParsed[\"traces\"];\n\n\treadonly rawMessage?: string;\n\treadonly rawTrace?: string[];\n\treadonly rawStack?: string;\n\n\tconstructor(stack: string, detectMessage?: string)\n\t{\n\t\tObject.assign(this, parseStack(stack, detectMessage))\n\t}\n\n\t/**\n\t * filterFunction Function the same as the callback function of Array.prototype.filter(callback)\n\t */\n\tfilter(filter: (value: ITraceValue, index: number, array: IParsed[\"traces\"]) => boolean)\n\t{\n\t\tthis.traces = this.traces.filter(filter)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Format object parsed\n\t */\n\tformat()\n\t{\n\t\treturn stringifyErrorStack(this)\n\t}\n}\n\nexport function formatTraces(traces: IParsed[\"traces\"])\n{\n\treturn traces?.map(formatTraceLine)\n}\n\n/**\n * Format object parsed\n */\nexport function stringifyErrorStack(parsed: ITSRequireAtLeastOne<IParsed, 'traces' | 'rawTrace'>)\n{\n\tconst messageLines = `${formatMessage(parsed)}`\n\tconst tracesLines = (parsed.traces?.map(formatTraceLine) ?? parsed.rawTrace)\n\t\t.join(LF)\n\t;\n\n\treturn tracesLines\n\t\t? messageLines + LF + tracesLines\n\t\t: messageLines\n}\n\nexport function parseErrorStack(stack: string, detectMessage?: string)\n{\n\treturn new ErrorStack(stack, detectMessage)\n}\n\nexport default parseErrorStack\n"],"names":["trim","s","isUnset","v","isNumOnly","test","toString","REGEX_MATCH_MESSAGE","REGEX_MATCH_MESSAGE_LOOSE","RegExp","source","flags","REGEX_REMOVE_AT","REGEX_STARTS_WITH_EVAL_AT","REGEX_MATCH_INDENT","breakBrackets","str","first","last","endsWith","firstIndex","cursor","length","count","char","charAt","slice","map","validPosition","line","col","parseSource","rawSource","stringSplitWithLimit","parseEvalSource","rawEvalSource","indent","rawLine","_detectIndent","rawTrace","rawEvalTrace","replace","split","eval","ev","callee","evalCallee","calleeNote","evalCalleeNote","trace","parseTrace","evalTrace","exec","testEvalSource","t","rawCallee","ret","startsWith","Object","assign","isEvalSource","validTrace","raw","isRawLineTrace","parseBody","rawStack","detectMessage","rawMessage","type","message","parseMessage","mf","formatMessage","indexOf","m","R_CRLF","index","lineSplit","input","_rawMessage","findIndex","trimLeft","splice","join","LF","body","looseMode","code","match","e","inspect","errcode","parseStack","TypeError","traces","formatTrace","sourceTrace","filter","formatEvalTrace","formatMessagePrefix","parsed","formatRawLineTrace","isEvalTrace","formatTraceLine","ErrorStack","constructor","stack","this","format","stringifyErrorStack","messageLines","tracesLines","_parsed$traces","parseErrorStack"],"mappings":"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"}